---
title: 前端工程化
date: 2017-11-04 10:35:34
updated: 2017-11-04 10:35:34
tags:
  - 架构
categories:
  - 构建
toc: true
---
前端工程化学习整理。

TODO：

> - 太多太多，慢慢细化记录构建的坑和优化对比

<!-- more -->

# 前端工程化概念

## 《浅析前端工程化》

### 1.什么是前端工程化

### 2.前端工程化面临的问题

要解决前端工程化的问题，可以从两个角度入手：*开发*和*部署*。

从开发角度，要解决的问题包括：

1. 提高开发生产效率；
2. 降低维护难度。

这两个问题的解决方案有两点：

1. 制定开发规范，提高团队协作能力；
2. 分治。软件工程中有个很重要的概念叫做*模块化开发*其中心思想就是分治。

从部署角度，要解决的问题主要是**资源管理**，包括：

1. 代码审查；
2. 压缩打包；
3. 增量更新；
4. 单元测试；

要解决上述问题，需要引入**构建/编译**阶段。

#### 2.1 开发规范

推荐[Airbnb的eslint规范](https://github.com/airbnb/javascript)

#### 2.2 模块/组件化开发

##### 2.2.1 模块还是组件？

两者的区别主要在**颗粒度**方面。

简单讲，module侧重的是对属性的封装，重心是在设计和开发阶段，不关注runtime的逻辑。module是一个白盒；而component是一个可以独立部署的软件单元，面向的是runtime，侧重于产品的功能性。component是一个黑盒，内部的逻辑是不可见的。

用通俗的话讲，模块可以理解为零件，比如轮胎上的螺丝钉；而组件则是轮胎，是具备某项完整功能的一个整体。具体到前端领域，一个button是一个模块，一个包括多个button的nav是一个组件。

##### 2.2.2 模块/组件化开发的必要性

模块/组件化开发的核心思想是**分治**，主要针对的是开发和维护阶段。

### 3. 构建&编译

#### 3.1 构建在前端工程中的角色

典型的web前后端协作模式

![典型的web前后端协作模式](http://images2015.cnblogs.com/blog/595796/201604/595796-20160411142716207-1803317219.png)

大前端模式的构建：

![大前端模式的构建](http://images2015.cnblogs.com/blog/595796/201604/595796-20160411142733598-1823214206.png)

构建的作用就是对静态资源以及模板进行处理，换句话说：**构建的核心是资源管理**。

#### 3.2 资源管理要做什么？

前端的资源可以分为**静态资源**和**模板**。构建过程中需要对两种资源使用不同的构建策略。

##### 3.2.1 静态资源构建策略

通常开发阶段的静态资源是：

1. es6/7规范的文件；
2. less/sass等文件（具体看团队技术选型）；
3. [可选]独立的小图标，在构建阶段使用工具处理成spirit图片。

构建阶段在处理这些静态文件时，基本的功能应包括：

1. es6/7转译，比如babel；
2. 将less/sass编译成css；
3. spirit图片生成；

静态资源的构建处理还需要考虑web应用的**性能因素**，构建阶段需要包括以下功能：

1. 依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；
2. 资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；
3. 文件压缩。减小文件体积；
4. hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；
5. 代码审查。避免上线文件的低级错误；

对比目前较流行的一些构建产品，比如fis，它具备以上所得的编译功能，同时提供了一些机制以**提高开发阶段的生产效率**。包括：

1. 文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；
2. mock server。并非所有前端团队都是大前端，即使在大前端体系下，mock server的存在也是很有必要的；

##### 3.2.2 模板的构建策略

模板与静态资源是*容器-模块*关系。模板直接引用静态资源，经过构建后，静态资源的改动有以下几点：

1. url改变。开发环境与线上环境的url肯定是不同的，不同类型的资源甚至根据项目的CDN策略放在不同的服务器上；
2. 文件名改变。静态资源经过构建之后，文件名被加上hash指纹，内容的改动导致hash指纹的改变。

对于模板的构建宗旨是在**静态资源url和文件名改变后，同步更新模板中资源的引用地址**。

这种模式下fis的**资源映射表**机制是非常好的解决方案。

##### 3.2.3 小结

构建可以分为**工具层面**和**平台层面**的功能：

工具层面

1. 预编译，包括es6/7语法转译、css预编译器处理、spirit图片生成；
2. 依赖打包；
3. 资源嵌入；
4. 文件压缩；
5. hash指纹；
6. 代码审查；
7. 模板构建。

平台层面

1. 文件监听，动态编译；
2. mock server。



## 《谁能介绍下web前端工程化》

### 模块化

模块化就是**将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载**。

#### JS的模块化

社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。

ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。

模块的打包和加载问题：

1. 用 Webpack + Babel将所有模块打包成一个文件同步加载，也可以打成多个chunk异步加载；（主流）
2. 用 SystemJS+Babel 主要是分模块异步加载；
3. 用浏览器的`<script type="module">`加载

#### CSS的模块化

虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：**选择器的全局污染问题**。

解决方法：

- 各厂都制定了自己的CSS命名风格。弱约束
- 工具层面：Shadow DOM、CSS in JS和CSS Modules三种解决方案
  - Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；
  - CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；[polished.js](https://polished.js.org/)，柯里化
  - CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。一种哈希文件名的实现，只加入了局部作用域和模块依赖。CSS Modules 内部通过 [ICSS](https://github.com/css-modules/icss) 来解决样式导入和导出这两个问题。分别对应 `:import` 和 `:export` 两个新增的伪类。

#### 资源的模块化

资源模块化后，有三个好处：

1. 依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；
2. 资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等。
3. 项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数：dest = webpack(src, config)

### 组件化

模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。

从UI拆分下来的**每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。**

其实，组件化更重要的是一种**分治思想**。

传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。

其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式**对面向对象的进一步抽象**。

所以我们除了封装组件本身，还要合理处理组件之间的关系，比如**（逻辑）继承**、**（样式）扩展**、**（模板）嵌套**和**包含**等，这些关系都可以归为**依赖**。

###  规范化

一些内容：

- 目录结构的制定
- 编码规范
- 前后端接口规范
- 文档规范
- 组件管理
- Git分支管理
- Commit描述规范
- 定期CodeReview
- 视觉图标规范
- ...

### 自动化

#### 图标合并

Webpack

#### 持续集成

#### 自动化构建

#### 自动化部署

#### 自动化测试

比如：Karma + Mocha + Chai



# 深入

## RequireJS

### RequireJS使用





## SPA理解

### 作用（好处）

1. 由于避免了页面的重新加载，SPA可以提供较为流畅的用户体验。得益于Ajax，可以实现无跳转刷新，由于与浏览器的history机制，可以使用hash的b变化从而可以实现推动界面变化。
2. 只要使用支持HTML5和CSS3的浏览器就可以执行复杂的SPA,因此，开发人员不必为了写SPA网站而特别学习另一个开发方式，而使用者也不额外安装软件，所以，让开发SPA网页程序的入门和使用门槛降低不少。

### 缺点

以SPA方式开发的网站不容易管理也不够安全。
因为没了一页一页的网页给搜索引擎的爬虫来爬，所以，在搜索引擎最佳化（SEO）的工作上，需要花费额外的功夫。
因为没有换页，需要自定义状态来取代传统网页程序以网址来做判断。

### 实现SPA

**技术：**

1. 处理#后面的字符
2. 局部刷新


## Babel的原理

但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

> ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码

Babel工作分为三个阶段:

1. 解析:将代码字符串解析成抽象语法树
2. 变换:将抽象语法树
3. 根据变换后的抽象语法树再生成代码字符串

## Babel的一些转化

### A.动态字符使用反引号

```javascript
const a = 'foobar';
const b = `foo${a}bar`;

var a = 'foobar';
var b = 'foo' + a + 'bar';
```

### B.解构

```javascript
const arr = [1, 2, 3, 4];
const [first, second] = arr;

var arr = [1, 2, 3, 4];
var first = arr[0],
    second = arr[1];
```

### C.默认参数

```javascript
function concateAll(...args){
    return args.join('');
}

function concateAll() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }
    return args.join('');
}
```



## Gzip压缩工作原理

Web服务器处理HTTP压缩的过程如下：

1. Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）；
2. 如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名；
3. 如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件；
4. 如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件；
5. 如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件；
6. 如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。




# 问题

## ES6模块系统





# 参考文章

- [谁能介绍下web前端工程化？](https://www.zhihu.com/question/24558375)
- [浅析前端工程化](http://www.cnblogs.com/ihardcoder/p/5378290.html)
- [用Gzip对网页内容进行压缩详解](http://hzp.iteye.com/blog/1833619)

