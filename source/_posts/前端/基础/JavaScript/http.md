---
title: http
date: 2017-05-01 20:36:34
updated: 2017-05-01 20:36:34
tags:
  - JavaScript
categories:
  - 基础
toc: true
---
本文介绍http。

<!-- more -->
# 知识点

## TCP/IP协议族

TCP/IP协议族可以分为4层，分别是应用层、传输层、网络层和链路层。

- 应用层：决定了向用户提供应用服务时通信的活动。FTP（File Transfer Protocol， 文件传输协议）、DNS（Domain Name System，域名系统）和HTTP都属于该层。
- 传输层：提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据协议）都属于该层。
- 网络层：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。
- 链路层：用来处理网络的硬件部分，包括操作系统、硬件的设备驱动、NIC（Network Interface Card，网卡）、光纤、诸如连接器之类的传输媒介等物理可见部分。

### 三次握手

三次握手的过程使用了TCP 标志——SYN（synchronize）和ACK（acknowledgement）：

1. 发送端发送一个带SYN标志的数据包给对方。
2. 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。
3. 发送端回传一个带ACK标志的数据包，表示握手结束。

## HTTP通信

利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通讯。以HTTP举例来说，过程是这样的：

1. 客户端在应用层（HTTP协议）发出一项想看某个Web页面的HTTP请求。
2. 在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。
3. 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。

发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的**首部信息**；反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法，也叫封装（encapsulate）。

## HTTP请求

**Case**

> GET /search.jsp HTTP/1.1
> Host: g.hxgoogle.com

一个完整的请求报文由Header和Body组成，Header包括请求方法、请求URI、协议版本、可选的请求首部字段等，Body指报文主体。下面重点介绍一下请求URI和HTTP方法。

### URI和URL

URI表示统一资源标识符，是Uniform Resource Identifier的缩写。

URI就是由某个协议方案（如http、ftp）表示的资源的定位标识符。

**Case**

> ftp://ftp.is.co.za/rfc/rfc1808.txt
> http://www.ietf.org/rfc/rfc2396.txt
> ldap://[2001:db8::7]/c=GB?objectClass?one
> mailto:John.Doe@example.com
> tel:+1-816-555-1212

URI用字符串标识某一互联网资源，而我们相对来说更熟悉的URL（UniformResource Locator，统一资源定位符）则是表示资源的地点。显然URL是URI的子集

HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：`http://host[":"port][abs_path]`

http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。

### HTTP方法

HTTP/1.1中的方法：

- GET：请求访问已被URI识别的资源，资源经服务器端解析后返回响应内容。
- POST：虽然GET方法也可以在Body中包含内容进行传输，不过一般不用，而是使用POST方法。POST在RESTful架构中一般用来修改资源。
- PUT：用于传输资源到URI指定位置进行保存。由于PUT方法自身不带验证机制，存在安全问题，因此一般Web网站不使用该方法。若配合Web应用程序的验证机制或采用RESTful架构设计，可能会开放使用。PUT在RESTful架构中一般用来添加资源。
- DELETE：删除资源。与PUT情况类似，一般不开放。
- HEAD：获得报文首部（Header），用于确认URI的有效性及资源的更新日期等。
- TRACE：追踪路径。发送请求时，在请求Header中加上Max-Forwards字段，譬如Max-Forwards: 2这样，每经过一个服务器就将该数字减1，当数字为0时停止传输，最后接收到请求的服务器返回状态码200 OK响应，响应包含最初的请求内容（将HTTP请求原样返回）。
- CONNECT：要求在于代理服务器通信时建立隧道，用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer， 安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。格式为CONNECT 代理服务器名:端口号 HTTP版本号。

## HTTP响应

HTTP响应同样可分为Header和Body，它一般长这样：

> HTTP/1.1 200 ok
> Date: ...
> Server: ..
> ...
> 空行(CR + LF)
> <html>
> ...
> </html>

### 状态码

状态码的第一位数字指定了响应类别，共可分为5类：

- 1XX：Informational（信息性状态码），表明接受的请求正在处理。
- 2XX：Success（成功状态码），表明请求正常处理完毕。
- 3XX：Redirection（重定向状态码），表明需进行附加操作以完成请求。
- 4XX：Client Error（客户端错误状态码），表明服务器无法处理请求。
- 5XX：Server Error（服务器错误状态码），表明服务器处理请求出错。

下面列举几种常见的错误码和原因短语：

- 200 OK：请求正常处理。
- 204 No Content：请求正常处理，但没有资源可返回。
- 206 Partial Content： 客户端进行了范围请求，服务器成功执行这部分GET请求。
- 301 Moved Permanently： 永久性重定向，表明该资源已被分配了新的URI。
- 302 Found： 临时性重定向，表明该资源暂时被分配了新的URI。
- 303 See Other：表明请求的资源存在另一个URI，明确要求客户端采用GET方法重定向请求资源。
- 400 Bad Request：请求报文中存在语法错误，需修改请求内容后再次发送。
- 401 Unauthorized*：请求需包含通过HTTP认证（BASIC认证、DIGEST认证等）的认证信息，浏览器初次接收401响应会弹出认证窗口。若之前已进行过一次请求，则表示用户认证失败。
- 403 Forbidden：请求资源的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，不过也可以在响应主体部分对原因进行描述。未获得文件系统的访问授权（比如在IIS上部署网站时默认不能通过浏览器访问文件）、访问权限出现问题（比如从未授权的发送源IP地址试图访问）都有可能返回403响应。
- 404 Not Found：服务器无法找到请求的资源（也可在服务器端拒绝访问且不想说明理由时使用）。
- 500 Internal Server Error：服务器端执行请求时发生内部错误。多为服务器端程序出现Bug。
- 503 Service Unavailable：服务器处于超负载或正在停机维护，暂时无法处理请求。

## HTTP消息报头

HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。

### 1. 普通报头

在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息

#### 常用的普通报头

**Cache-Control**
Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。

请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;
响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.

**Date**
Date普通报头域表示消息产生的日期和时间

**Connection**
Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接

### 2. 请求报头

请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。

#### 常用的请求报头

**Accept**
Accept请求报头域用于指定客户端接受哪些类型的信息。

**Accept-Charset**
Accept-Charset请求报头域用于指定客户端接受的字符集。

**Accept-Encoding**
Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。

**Accept-Language**
Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。

**Authorization**
Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。

**Host**（发送请求时，该报头域是必需的）
Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的

**User-Agent**
User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的

### 3. 响应报头

响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。

#### 常用的响应报头

**Location**
Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。

**Server**
Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。

### 4. 实体报头

请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。

#### 常用的实体报头

**Content-Encoding**
Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。

**Content-Language**
Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。

**Content-Length**
Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。

**Content-Type**
Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。

**Last-Modified**
Last-Modified实体报头域用于指示资源的最后修改日期和时间。

**Expires**
Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。

## HTTP协议的一些特性

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。增加通信量的开销，而且频繁断开又重连会导致页面加载缓慢，影响用户体验。

### 持久连接（HTTP Persistent Connections）

HTTP/1.1和一部分HTTP/1.0开始支持持久连接。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。HTTP/1.1中所有的连接默认都是持久连接。

### 管线化（pipelining）

持久连接使得多数请求以管线化方式发送成为可能。以往发送请求后需等待并收到响应后才能发送下一个请求，管线化技术出现后，无需等待亦可发送下一个请求。这就实现了多个请求的并行发送，提高了网络通信效率。

### Cookie

HTTP是无状态协议，它不对之前发生过的请求和响应状态进行管理。HTTP协议中引入的Cookie技术，也是为了解决状态管理问题。

具体来说，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态，过程如下：

1. 客户端第一次发送请求，请求报文中没有Cookie信息。

2. 服务器端生成Cookie信息，在响应报文中通过Set-Cookie这个首部字段，通知客户端保存Cookie，大概长这样：

   > HTTP/1.1 200 ok
   > ...
   > <Set-Cookie: sid=1345077140226724;path=/;expires=Fri,=>23-Oct-15 07:12:20 GMT>
   > Content-Type: text/plain; charset=UTF-8

3. 客户端再次发送请求时，自动在请求报文中加入Cookie值后发送出去。大概长这样：

   > GET /image/ HTTP/1.1
   > Host: github.com
   > Cookie: sid=1345077140226724

4. 服务器端收到Cookie信息后，会去检查从哪个客户端发来的连接请求，然后对比服务器上的记录，得到之前的状态信息。


## HTTP协议相关技术补充

### 中介

中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)。

#### 代理(Proxy)

一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。

一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。

#### 网关(Gateway)

一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。

网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。

#### 通道(Tunnel)

是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。

一个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。



# 问题

## HTTP协议的主要特点

1. 支持客户/服务器模式。
2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。





# 参考文章

- [HTTP知识点总结](http://www.jianshu.com/p/2ecd288d27ad)
- [HTTP协议详解（前端面试常考知识点）](http://www.cnblogs.com/puyaoyao/p/3705970.html)