---
title: 内存泄漏
date: 2017-04-29 18:08:34
updated: 2017-04-29 18:08:34
tags:
  - JavaScript
categories:
  - 基础
toc: true
---
本文介绍JS内存泄漏

<!-- more -->
# 知识点

## js的回收机制

垃圾收集算法所依赖的主要概念之一就是内存引用。

在内存管理情况下，如果一个对象访问变量（可以是隐含的或显式的），则称该对象引用另一个对象。

通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。

### 标记清除

标记和扫描算法经过以下3个步骤：

1. roots：通常，root是代码中引用的全局变量。例如，在JavaScript中，可以充当root的全局变量是“窗口”对象。Node.js中的相同对象称为“全局”。所有root的完整列表由垃圾收集器构建。
2. 然后算法会检查所有root和他们的子对象并且标记它们是活动的（即它们不是垃圾）。任何root不能达到的，将被标记为垃圾。
3. 最后，垃圾回收器释放所有未标记为活动的内存块，并将该内存返回给操作系统。

![](http://jbcdn2.b0.upaiyun.com/2017/11/f3a624c2b1f1a9a511deffc4ad1bd57a.gif)

这个算法比引用计数垃圾收集算法更好。

### 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

## 抵制垃圾收集器的直观行为

垃圾收集是不可预测的。你不能真正知道什么时候进行收集，这意味着在某些情况下，程序会使用更多的内存，虽然这是实际需要的。在其它情况下，在特别敏感的应用程序中，短暂暂停是很可能出现的。尽管非确定性意味着不能确定何时进行集合，但大多数垃圾收集实现了共享在分配期间进行收集的通用模式。如果没有执行分配，大多数垃圾收集会保持空闲状态。如以下情况：

1. 大量的分配被执行。
2. 大多数这些元素（或所有这些元素）被标记为无法访问（假设我们将一个引用指向不再需要的缓存）。
3. 没有进一步的分配执行。

## 常见内存泄漏

### 全局变量

当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window。如果不小心创建一个全局变量this，会有一些问题。

通过加上 'use strict' 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.

意外的全局变量当然是一个问题。更多的时候，你的代码会受到显式的全局变量的影响，而这些**全局变量在垃圾收集器中是无法收集的**。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，那么确保将其分配为空值，或者在完成后重新分配。

### 闭包引起的内存泄漏

- 将事件处理函数定义在外部，解除闭包,


- 在定义事件处理函数的外部函数中，删除对dom的引用

### 超出DOM引用

在某些情况下，开发人员会在数据结构中存储DOM节点，例如你想快速更新表格中的几行内容的情况。如果在字典或数组中存储对每个DOM行的引用，则会有两个对同一个DOM元素的引用：一个在DOM树中，另一个在字典中。如果你不再需要这些行，则需要使两个引用都无法访问。

在涉及DOM树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（标签）的引用，并决定从DOM中删除该表格，还需要保留对该特定单元格的引用，则可能会出现严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元之外的所有东西，但情况并非如此。由于单元格是表格的一个子节点，并且子节点保留着对父节点的引用，所以对表格单元格的这种引用，会将整个表格保存在内存中。

### 被遗忘的定时器或者回调

对于提供监视的库和其它接受回调的工具，通常在确保所有回调的引用在其实例无法访问时，会变成无法访问的状态。

当使用监视器时，你需要确保做了一个明确的调用来删除它们。

幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当被监测对象变得无法访问，它们就会自动收集监测处理器。这是过去的一些浏览器无法处理的情况（例如旧的IE6）。



# 问题

## IE7/8引用计数使用循环引用产生的问题

```javascript
function fn(){
  var a = {};
  var b= {};
  a.pro = b;
  b.pro = a;
}
fn();
```

在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。

IE中有一部分对象并不是原生js对象。例如，其内存泄漏DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。

IE9+并不存在循环引用导致Dom内存泄漏问题




# 参考文章

- [JS哪些操作会造成内存泄漏？](http://www.jianshu.com/p/763ba9562864)
- [JavaScript 中的内存泄漏以及如何处理](http://web.jobbole.com/93078/)